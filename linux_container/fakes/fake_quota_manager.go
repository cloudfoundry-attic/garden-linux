// This file was generated by counterfeiter
package fakes

import (
	"sync"

	"github.com/cloudfoundry-incubator/garden"
	"github.com/cloudfoundry-incubator/garden-linux/linux_container"
	"github.com/pivotal-golang/lager"
)

type FakeQuotaManager struct {
	SetLimitsStub        func(logger lager.Logger, containerRootFSPath string, limits garden.DiskLimits) error
	setLimitsMutex       sync.RWMutex
	setLimitsArgsForCall []struct {
		logger              lager.Logger
		containerRootFSPath string
		limits              garden.DiskLimits
	}
	setLimitsReturns struct {
		result1 error
	}
	GetLimitsStub        func(logger lager.Logger, containerRootFSPath string) (garden.DiskLimits, error)
	getLimitsMutex       sync.RWMutex
	getLimitsArgsForCall []struct {
		logger              lager.Logger
		containerRootFSPath string
	}
	getLimitsReturns struct {
		result1 garden.DiskLimits
		result2 error
	}
	GetUsageStub        func(logger lager.Logger, containerRootFSPath string) (garden.ContainerDiskStat, error)
	getUsageMutex       sync.RWMutex
	getUsageArgsForCall []struct {
		logger              lager.Logger
		containerRootFSPath string
	}
	getUsageReturns struct {
		result1 garden.ContainerDiskStat
		result2 error
	}
	MountPointStub        func() string
	mountPointMutex       sync.RWMutex
	mountPointArgsForCall []struct{}
	mountPointReturns     struct {
		result1 string
	}
	DisableStub          func()
	disableMutex         sync.RWMutex
	disableArgsForCall   []struct{}
	IsEnabledStub        func() bool
	isEnabledMutex       sync.RWMutex
	isEnabledArgsForCall []struct{}
	isEnabledReturns     struct {
		result1 bool
	}
}

func (fake *FakeQuotaManager) SetLimits(logger lager.Logger, containerRootFSPath string, limits garden.DiskLimits) error {
	fake.setLimitsMutex.Lock()
	fake.setLimitsArgsForCall = append(fake.setLimitsArgsForCall, struct {
		logger              lager.Logger
		containerRootFSPath string
		limits              garden.DiskLimits
	}{logger, containerRootFSPath, limits})
	fake.setLimitsMutex.Unlock()
	if fake.SetLimitsStub != nil {
		return fake.SetLimitsStub(logger, containerRootFSPath, limits)
	} else {
		return fake.setLimitsReturns.result1
	}
}

func (fake *FakeQuotaManager) SetLimitsCallCount() int {
	fake.setLimitsMutex.RLock()
	defer fake.setLimitsMutex.RUnlock()
	return len(fake.setLimitsArgsForCall)
}

func (fake *FakeQuotaManager) SetLimitsArgsForCall(i int) (lager.Logger, string, garden.DiskLimits) {
	fake.setLimitsMutex.RLock()
	defer fake.setLimitsMutex.RUnlock()
	return fake.setLimitsArgsForCall[i].logger, fake.setLimitsArgsForCall[i].containerRootFSPath, fake.setLimitsArgsForCall[i].limits
}

func (fake *FakeQuotaManager) SetLimitsReturns(result1 error) {
	fake.SetLimitsStub = nil
	fake.setLimitsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuotaManager) GetLimits(logger lager.Logger, containerRootFSPath string) (garden.DiskLimits, error) {
	fake.getLimitsMutex.Lock()
	fake.getLimitsArgsForCall = append(fake.getLimitsArgsForCall, struct {
		logger              lager.Logger
		containerRootFSPath string
	}{logger, containerRootFSPath})
	fake.getLimitsMutex.Unlock()
	if fake.GetLimitsStub != nil {
		return fake.GetLimitsStub(logger, containerRootFSPath)
	} else {
		return fake.getLimitsReturns.result1, fake.getLimitsReturns.result2
	}
}

func (fake *FakeQuotaManager) GetLimitsCallCount() int {
	fake.getLimitsMutex.RLock()
	defer fake.getLimitsMutex.RUnlock()
	return len(fake.getLimitsArgsForCall)
}

func (fake *FakeQuotaManager) GetLimitsArgsForCall(i int) (lager.Logger, string) {
	fake.getLimitsMutex.RLock()
	defer fake.getLimitsMutex.RUnlock()
	return fake.getLimitsArgsForCall[i].logger, fake.getLimitsArgsForCall[i].containerRootFSPath
}

func (fake *FakeQuotaManager) GetLimitsReturns(result1 garden.DiskLimits, result2 error) {
	fake.GetLimitsStub = nil
	fake.getLimitsReturns = struct {
		result1 garden.DiskLimits
		result2 error
	}{result1, result2}
}

func (fake *FakeQuotaManager) GetUsage(logger lager.Logger, containerRootFSPath string) (garden.ContainerDiskStat, error) {
	fake.getUsageMutex.Lock()
	fake.getUsageArgsForCall = append(fake.getUsageArgsForCall, struct {
		logger              lager.Logger
		containerRootFSPath string
	}{logger, containerRootFSPath})
	fake.getUsageMutex.Unlock()
	if fake.GetUsageStub != nil {
		return fake.GetUsageStub(logger, containerRootFSPath)
	} else {
		return fake.getUsageReturns.result1, fake.getUsageReturns.result2
	}
}

func (fake *FakeQuotaManager) GetUsageCallCount() int {
	fake.getUsageMutex.RLock()
	defer fake.getUsageMutex.RUnlock()
	return len(fake.getUsageArgsForCall)
}

func (fake *FakeQuotaManager) GetUsageArgsForCall(i int) (lager.Logger, string) {
	fake.getUsageMutex.RLock()
	defer fake.getUsageMutex.RUnlock()
	return fake.getUsageArgsForCall[i].logger, fake.getUsageArgsForCall[i].containerRootFSPath
}

func (fake *FakeQuotaManager) GetUsageReturns(result1 garden.ContainerDiskStat, result2 error) {
	fake.GetUsageStub = nil
	fake.getUsageReturns = struct {
		result1 garden.ContainerDiskStat
		result2 error
	}{result1, result2}
}

func (fake *FakeQuotaManager) MountPoint() string {
	fake.mountPointMutex.Lock()
	fake.mountPointArgsForCall = append(fake.mountPointArgsForCall, struct{}{})
	fake.mountPointMutex.Unlock()
	if fake.MountPointStub != nil {
		return fake.MountPointStub()
	} else {
		return fake.mountPointReturns.result1
	}
}

func (fake *FakeQuotaManager) MountPointCallCount() int {
	fake.mountPointMutex.RLock()
	defer fake.mountPointMutex.RUnlock()
	return len(fake.mountPointArgsForCall)
}

func (fake *FakeQuotaManager) MountPointReturns(result1 string) {
	fake.MountPointStub = nil
	fake.mountPointReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeQuotaManager) Disable() {
	fake.disableMutex.Lock()
	fake.disableArgsForCall = append(fake.disableArgsForCall, struct{}{})
	fake.disableMutex.Unlock()
	if fake.DisableStub != nil {
		fake.DisableStub()
	}
}

func (fake *FakeQuotaManager) DisableCallCount() int {
	fake.disableMutex.RLock()
	defer fake.disableMutex.RUnlock()
	return len(fake.disableArgsForCall)
}

func (fake *FakeQuotaManager) IsEnabled() bool {
	fake.isEnabledMutex.Lock()
	fake.isEnabledArgsForCall = append(fake.isEnabledArgsForCall, struct{}{})
	fake.isEnabledMutex.Unlock()
	if fake.IsEnabledStub != nil {
		return fake.IsEnabledStub()
	} else {
		return fake.isEnabledReturns.result1
	}
}

func (fake *FakeQuotaManager) IsEnabledCallCount() int {
	fake.isEnabledMutex.RLock()
	defer fake.isEnabledMutex.RUnlock()
	return len(fake.isEnabledArgsForCall)
}

func (fake *FakeQuotaManager) IsEnabledReturns(result1 bool) {
	fake.IsEnabledStub = nil
	fake.isEnabledReturns = struct {
		result1 bool
	}{result1}
}

var _ linux_container.QuotaManager = new(FakeQuotaManager)
